'''
8x8 multiplication targeting Ryzen and Skylake, modification of mul8_zen. Uses
 aligned loads of v[] into xmm's
'''

import os, re, sys
sys.dont_write_bytecode = 1

import gen_mul4 as P
import gen_mul8_zen as E

g_preamble = '''
vzeroupper
movq dd, w0
and $0xF, dd
movq (w0), dd
jz align0
'''

g_load0 = '''
movq 8(w0), t0
movdqa 16(w0), t1
movdqa 32(w0), t2
movdqa 48(w0), t3
'''

def extract_v(i, t, align):
    if align == 8:
        if (i == 1):
            return 'movq t0, ' + t
        if (i == 2):
            return 'pextrq $0x1, t0, ' + t
        if (i == 3):
            return 'movq t1, ' + t
        if (i == 4):
            return 'pextrq $0x1, t1, ' + t
        if (i == 5):
            return 'movq t2, ' + t
        if (i == 6):
            return 'pextrq $0x1, t2, ' + t
        if (i == 7):
            return 'movq t3, ' + t
    else:
        if (i == 1):
            return 'movq t0, ' + t
        if (i == 2):
            return 'movq t1, ' + t
        if (i == 3):
            return 'pextrq $0x1, t1, ' + t
        if (i == 4):
            return 'movq t2, ' + t
        if (i == 5):
            return 'pextrq $0x1, t2, ' + t
        if (i == 6):
            return 'movq t3, ' + t
        if (i == 7):
            return 'pextrq $0x1, t3, ' + t

def mul1_code(i, jj, p, align):
    rr = ['# mul_add %s %s' % (align, i)]
    for j in jj:
        if j.find(':=v[i+1]') != -1:
            j = extract_v(i+1, j[:2], align)
            if not j:
                continue
        rr.append(j)

    if i == 7:
        rr = rr[:-1] + P.cutoff_comments(E.g_tail)

    # apply permutation p, replace i(rp)
    for y in range(len(rr)):
        src = rr[y]
        for x in range(12):
            a = '%X' % x
            b = '%X' % p[x]
            src = re.sub(r'\bs%s\b' % a, 'w' + b, src)
        src += ' '
        for x in range(1, 9):
            ' replace i+x with 8*(i+x) '
            src = src.replace('i+%s(' % x, '%s(' % (8 * (i + x)))
        ' replace i with 8*i '
        src = src.replace('i(', '%s(' % (8 * i)) + ' '
        rr[y] = src.rstrip()

    return rr

def cook_asm(o, code):
    xmm_save = P.save_registers_in_xmm(code, 9)

    P.insert_restore(code, xmm_save)
    code = '\n'.join(code)
    for k,v in xmm_save.items():
        code = code.replace('!restore ' + k, 'movq %s, %s' % (v, k))

    code = P.replace_symbolic_names_wr(code, E.g_reg_map)
    code = code.replace('movdqu', 'movdqa')

    comment = P.g_autogenerated_patt % os.path.basename(sys.argv[0])
    o.write(comment.replace('//', '#'))
    P.write_asm_procedure_header(o, P.guess_subroutine_name(sys.argv[1]))
    P.write_asm_inside(o, code + '\nretq')

def alignment_code(shift):
    p = list(range(12))
    m = P.cutoff_comments(E.g_muladd_2)
    meat = mul1_code(2, m, p, shift)
    q = [int(x, 16) for x in E.g_perm.split(' ')]
    for i in range(3, 8):
        p = P.composition(p, q)
        meat += mul1_code(i, m, p, shift)
    return meat

def do_it(o):
    meat = P.cutoff_comments(g_preamble) + P.cutoff_comments(E.g_mul_01)[3:]
    meat += alignment_code(8)
    meat.append('align0:')
    meat += P.cutoff_comments(g_load0)
    meat += alignment_code(0)

    cook_asm(o, meat)

with open(sys.argv[1], 'wb') as g_out:
    do_it(g_out)
