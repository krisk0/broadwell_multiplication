"""
mpn_add_2_4arg(t, a, n, lc)

t := t + a + b

b starts at a + n

length of numbers is 4 + 4 * lc

vv: 128-bit scratch register

all 4 registers used as input parameters modified
"""

g_code = '''
xorq w5, w5                       | zero carries and w5
movq w5, vv                       | vv = 0
@save w2
movq (tt), w0
movq +1(tt), w1                   | w1 = t1
lea (aa, bb, 8), bb               | bb = address of b
!save w3
movq +2(tt), w2                   | w2 = t2
movq +3(tt), w3                   | w3 = t3
!save w4
adcx (aa), w0                     | w0 = t0 + a0
movq (bb), w4                     | w4 = b0
movq +1(bb), w5                   | w5 = b1                 
movq +2(bb), w6                   | w6 = b2
movq +3(bb), w7                   | w7 = b3                 
adcx +1(aa), w1                   | w1 = t1 + a1
adox w4, w0                       | w0 = r0
.align 32
loop:
lea +4(bb), bb                    | bb moved
adcx +2(aa), w2                   | w2 = t2 + a2
adox w5, w1                       | w1 = r1
movq (bb), w4                     | w4 = b4
movq +1(bb), w5                   | w5 = b5
lea +4(aa), aa                    | aa moved
movq w0, (tt)                     | w0 vacant, t[0] set
movq w1, +1(tt)                   | w1 vacant, t[1] set
adox w6, w2                       | w2 = r2
adcx -1(aa), w3                   | w3 = t3 + a3
movq +4(tt), w0                   | w0 = t4
movq +5(tt), w1                   | w2 = t5
adox w7, w3                       | w3 = r3
lea +4(tt), tt                    | tt moved
adcx (aa), w0                     | w0 = t4 + a4
movq w2, -2(tt)                   | w2 vacant, t[2] set
movq w3, -1(tt)                   | w3 vacant, t[3] set
movq +2(tt), w2                   | w2 = t6
movq +3(tt), w3                   | w3 = t7
adox w4, w0                       | w0 = r4
adcx +1(aa), w1                   | w1 = t5 + a5
movq +2(bb), w6                   | w6 = b6
movq +3(bb), w7                   | w7 = b7
loop loop
!restore w4
adox w5, w1                       | w1 = r5
adcx +2(aa), w2                   | w2 = t6 + a6
movq vv, w5                       | w5 = 0
adox w6, w2                       | w2 = r6
adcx +3(aa), w3                   | w3 = t7 + a7
movq w5, w6                       | w6 = 0
movq w0, (tt)                     | t[4] set
movq w1, +1(tt)                   | t[5] set
adox w3, w7                       | w7 = r7
!restore w3
adcx w6, w5                       | w5 = carry from t + a
movq w2, +2(tt)                   | t[6] set
movq w7, +3(tt)                   | t[7] set
@restore w2
adox w6, w5                       | w5 = final carry
'''

g_reg_map = 'tt rdi,aa rsi,bb rdx,lc cx,w5 rax,' + \
        'w0 r8,w1 r9,w2 rbp,w3 rbx,w4 r15,w6 r10,w7 r11'

g_saved_in_xmm = 'w3 w4'

import os, re, sys
sys.dont_write_bytecode = 1
import gen_mul4 as P

def do_it(o):
    me = os.path.basename(sys.argv[0])
    comment = P.g_autogenerated_patt % me
    o.write(comment.replace('//', '#'))
    P.write_asm_procedure_header(o, me[4:-3])
    # form reg_map, deal with save/restore
    reg_map = dict(x.split(' ') for x in g_reg_map.split(','))
    reg_map['vv'] = 'xmm15'
    k = 15
    code = g_code.strip()
    for r in g_saved_in_xmm.split(' '):
        n = r[1]
        k -= 1
        reg_map['s' + n] = 'xmm%s' % k
        # TODO: test and benchmark mpn_add2_4arg
        code = code.replace('!restore ' + r, 'movq s@, w@'.replace('@', n))
        code = code.replace('!save ' + r, 'movq w@, s@'.replace('@', n))
    # fix offsets
    code = P.replace_positive_offsets(code)
    code = P.replace_negative_offsets(code)
    # save/restore to red zone
    code = P.replace_amp_save(code)
    code = P.replace_amp_restore(code)
    # apply reg_map
    for k,v in reg_map.items():
        code = re.sub(r'\b%s\b' % k, '%' + v, code)
    # write file
    P.write_asm_inside(o, code + '\nretq')

g_tgt = sys.argv[1]

with open(g_tgt, 'wb') as g_o:
    do_it(g_o)
